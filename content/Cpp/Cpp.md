## struct和class的区别⭐

- *默认访问权限*：`struct`中的成员默认为==公共==`(public)`，而`class`中的成员默认为==私有==`(private)`。
- *默认继承方式*：`struct`中的继承方式默认为公共`(public)`，`class`中的继承方式默认为私有`(private)`。
- *使用习惯*：`struct`适合用于简单的数据结构，`class`适合用于复杂的数据类型和实现面向对象编程。
- *成员变量和成员函数*：`struct`中的成员变量和成员函数默认为公共，而`class`中的成员变量和成员函数默认为**私有**。
- *访问控制*：`struct`中的成员在外部可直接访问，而`class`中的成员需要使用公共的成员函数来访问。
- *默认的构造函数和析构函数*：`class`中会自动生成默认的==构造函数和析构函数==，而`struct`中不会。
## char和int之间的转换
### char转换为int

直接将`char`类型的变量赋值给`int`类型的变量，将字符对应的`ASCII`码值赋给`int`变量。
```c++
char c = 'A';
int i = c;  // 将字符'A'的ASCII码值赋给i
```
### int转换为char

可以使用**强制类型转换** `(static_cast<char>)` 将`int`类型的变量转换为`char`类型的变量，该方法只会截取`int`变量的==低位字节==作为字符。
```c++
int i = 65;
char c = static_cast<char>(i);  // 将整数65转换为对应的字符'A'
```

对于转换为`char`的`int`值，如果超出了`char`类型的范围`(-128至127)`，将会发生==溢出==，只保留==最低位字节==的值。
## 什么是野指针和悬挂指针⭐

### 野指针（Dangling Pointer）

1. *未初始化*：指的是==未初始化==过的指针，它指向的地址是未知的、不确定的、随机的。防止的措施就是指针初始化（包括**及时初始化**或**置空**）。
2. *指向已释放内存的指针*：即[[Cpp#悬挂指针（Dangling Reference）|悬挂指针]]
3. *数组越界访问*
4. *返回局部变量的地址*
### 悬挂指针（Dangling Reference）
> 特指指向已释放内存的指针。指针**指向**的==内存已释放==，但指针的值没有被清零，对悬空指针操作的==结果不可预知==。
```c++
int* createInt() {
    int value = 5;
    int* ptr = &value;
    return ptr; // 返回指向局部变量的指针
}

int main() {
    int* danglingPtr = createInt(); // 指向已释放的内存

    // 对悬挂指针操作的结果不可预知
    int value = *danglingPtr; // 解引用悬挂指针，可能导致未定义的行为

    return 0;
}
```
### 在函数中申请堆内存需要注意什么⭐
#### 问题
- 确保不要错误地返回指向*栈内存的指针*，因为栈内存会在函数结束时自动释放。
- 避免在函数内部申请*临时数组*，因为函数执行完成后，该数组会消失。
- 不要返回指向*常量区的内存空间*，因为它们无法修改且获取它们没有意义。
- 使用传入**一级指针**无法解决问题，因为函数内部指针的修改不会影响*传入的指针*。
- 在分配堆内存时，确保空间足够存储所需数据，避免访问*越界*和产生未定义行为。
#### 解决方式
- 使用==二级指针==来返 回申请的堆内存的地址，通过*间接引用*来修改指针值，从而确保在函数外部能够获取到堆内存的内容`void my_function(DataType** ptr) {}`。
- 使用*指针函数*来解决问题，即返回通过`malloc`函数申请的堆内存的地址，这样可以在函数外部使用free函数释放该内存`void* ptr = my_function(){};`。
## NULL和nullptr区别⭐

- *类型*不同：`NULL`是**宏定义**或**整数值0**，而`nullpt`r是`C++11`引入的==关键字==，表示**空指针**。
- *安全性*不同：`NULL`可能导致函数*调用二义性*问题，`nullptr`更安全，不会被错误解释为整型。
- *上下文匹配*不同：`NULL`可以用于**整型类型**的上下文，`nullptr`只能用于**指针类型**的上下文。

## 重载、重写和隐藏的区别⭐
### 重载（Overloading）

- 重载是在同一个作用域内定义多个相同名称但==参数列表==不同的函数或方法。
- 重载函数可以根据不同的*参数数量*或*类型*来执行不同的操作。
```c++
#include <iostream>

void printNumber(int num) {
    std::cout << "Integer number: " << num << std::endl;
}

void printNumber(double num) {
    std::cout << "Floating-point number: " << num << std::endl;
}

int main() {
    printNumber(10);
    printNumber(3.14);
    return 0;
}
```
### 重写（Override）

- 重写是指*子类*重新定义从父类继承的**虚函数**，使其具有不同的实现。
- 重写的==函数签名（函数名、参数列表和返回类型）==必须与被重写函数相同。
- 在运行时，根据具体的对象类型，调用的是子类重写的版本。
```c++
#include <iostream>

class Base {
public:
    virtual void sayHello() {
        std::cout << "Hello from Base class!" << std::endl;
    }
};

class Derived : public Base {
public:
    void sayHello() override {  // 使用 override 关键字表明重写了父类的函数
        std::cout << "Hello from Derived class!" << std::endl;
    }
};

int main() {
    Base* basePtr = new Derived();
    basePtr->sayHello();  // Output: "Hello from Derived class!"
    delete basePtr;
    return 0;
}

```
### 隐藏（Hiding）：
> 隐藏（`Hiding`）通常指的是基类中的成员被派生类中的同名成员隐藏的现象。
- 隐藏是指在*派生类*中定义与父类具有相同名称的成员函数，使其隐藏父类中的同名函数。
- 隐藏函数与父类的函数*没有多态性*，只有通过对象的实际类型调用时才会调用相应的函数。
## 面向对象的三大特性
### 封装（Encapsulation）
> 封装是将数据和操作封装在一个单元（类）中的机制。
- 通过封装，实现类的成员变量和成员函数作为一个整体进行管理和操作。
- 封装隐藏了数据的具体实现细节，只暴露出必要的接口，提供了更好的安全性和可维护性。
- 通过访问修饰符（公有、私有、保护），控制对类的成员的访问权限。
### 继承（Inheritance）
> 继承是通过创建派生类来扩展和重用已有类的机制。
- 基类（父类）是已经定义的类，派生类（子类）继承了基类的属性和方法。
- 子类可以自定义新的属性和方法，也可以覆盖或扩展继承的父类的属性和方法。
- 继承实现了类与类之间的关系，实现了代码的重用和扩展。
### 多态（Polymorphism）
> 多态是指同一个接口可以由不同的对象以不同的方式进行实现和响应的能力。
- 多态允许使用*基类*的指针或引用来引用派生类的对象，实现了多种形态的使用。
- **编译**时多态使用*函数重载*和*运算符重载*；**运行**时多态通过*虚函数*实现（动态绑定）。
- 多态提高了代码的灵活性和可扩展性，使得程序更具有可读性和可维护性。
#### 详细讲解下多态
利用*虚函数*，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。 基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（`Polymorphism`）。
```c++
#include <iostream>

class Base {
public:
    virtual void print() {
        std::cout << "This is the Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        std::cout << "This is the Derived class" << std::endl;
    }
};

int main() {
    Base* basePtr;
    
    Base baseObj;
    Derived derivedObj;
    
    basePtr = &baseObj;
    basePtr->print();  // 此时使用基类的成员函数来打印消息
    
    basePtr = &derivedObj;
    basePtr->print();  // 此时使用派生类的成员函数来打印消息
    
    return 0;
}
```
### 动态链接与静态链接区别

> 动态链接：

- 在**程序运行**时进行链接，加载共享库文件。
- 节省空间，可多个程序*共享*库文件。
- 灵活性高，可以动态加载不同版本的库文件。
- *维护方便*，只需更新库文件本身。

> 静态链接：

- 在**编译**时进行链接，将库函数复制到可执行文件中。
- *独立*的可执行文件，不依赖外部库文件。
- 可执行文件较大，可能会有*冗余*代码。
- 维护复杂，更新库函数需*重新编译*和分发可执行文件。

> 使用场景和优缺点：

- 动态链接适合节省资源、可升级和灵活性要求高的场景。但在运行时有一定开销。
- 静态链接适合独立部署和简化依赖关系的场景。但可执行文件较大且维护复杂。
### 静态绑定和动态绑定 ⭐

> 静态绑定发生在编译期，动态绑定发生在运行期
> 对象的动态类型可以更改，但是静态类型无法更改
> 要想实现动态，必须使用动态绑定
> 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定

- *静态类型*：对象在**声明**时使用的类型，在==编译==期就已经确定
- *动态类型*：**指针**变量或**引用**变量所指向对象的类型，在==运行==期才能确定
- *静态绑定*：绑定的是静态类型，对象的函数和属性依赖于绑定的静态类型，发生在==编译==期
- *动态绑定*：绑定的是动态类型，对象的函数和属性依赖于绑定的动态类型，发生在==运行==期
```c++
#include<iostream>

class Base {
public:
    virtual void display() {
        std::cout << "Base class display function" << std::endl;
    }
};

class Derived : public Base {
public:
    void display() override {
        std::cout << "Derived class display function" << std::endl;
    }
};

int main() {
    Base baseObj;
    Derived derivedObj;

    Base* ptr = nullptr;

    ptr = &baseObj;
    ptr->display();  // 静态绑定，输出 "Base class display function"

    ptr = &derivedObj;
    ptr->display();  // 动态绑定，输出 "Derived class display function"

    return 0;
}
/*定义了一个基类Base和派生类Derived。这两个类都有一个名为display的函数，其中派生类重写了基类的display函数。在main函数中，我们创建了一个基类指针ptr，并分别将其指向基类对象和派生类对象。

在静态绑定的情况下，当我们通过指针ptr调用display函数时，由于ptr的静态类型是基类指针，所以编译器会根据基类的函数定义来解析它，并调用基类的display函数。因此，输出结果为"Base class display function"。

然而，在动态绑定的情况下，当我们通过指针ptr调用display函数时，由于ptr的动态类型是派生类对象，所以在运行时会根据对象的实际类型来解析函数调用，并调用派生类的display函数。因此，输出结果为"Derived class display function"。*/
```
### C++与C在编译时的主要区别

> 函数重载、面向对象、兼容性
- 由于C++支持*函数重载*，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的==参数类型==，一般只包括函数名。
- *语法和功能*：C++相比C具有更多的语法和功能。C++引入了面向对象编程的概念，包括类、继承、多态等。此外，C++还提供了更多的库和工具，如标准模板库（`STL`）和异常处理机制等。
- *兼容性*：C++是C的==超集==，这意味着C的源代码可以直接在C++中编译和运行。C++编译器会自动识别和处理C的语法，因此可以使用C代码编写的功能和库
### 在C++中使用C代码有多种方式
> 使用==extern "C"==进行函数声明：在C++中，使用`extern "C"`修饰C代码的函数声明，以告诉编译器使用C的名称重载规则。
```c
	extern "C" {
	    // C函数声明
	    int add(int a, int b);
	}
```
> 在C++中包含C的==头文件==：在C++源文件中直接包含C的头文件，即`#include "my_c_code.h"`，然后直接使用其中声明的C函数和数据结构

> 使用`#ifdef __cplusplus`进行条件编译：在C的头文件中使用**条件编译**，根据`__cplusplus`宏定义来区分C和C++环境，在C++环境下使用`extern "C"`修饰C函数声明
```c
	#ifdef __cplusplus
	extern "C" {
	#endif
	
	// C函数声明
	int add(int a, int b);
	
	#ifdef __cplusplus
	}
	#endif
```
### 在C++中，推荐尽量避免过多使用宏的原因
> 可读性差、潜在副作用、缺乏类型检查
- *可读性差*：宏通常使用简单的**文本替换**机制，在代码中展开为复杂的表达式或语句，导致代码可读性降低。
- *潜在的副作用*：宏的使用可能导致潜在的副作用，比如多次求值、修改变量等，这可能导致意外行为和错误。
- *缺乏类型检查*：宏不进行**类型检查**，因此在使用宏时需要自行确保类型匹配，否则可能导致**运行时**错误。
### C++提供了一些替代方案来减少宏的使用
- *const和constexpr*：C++中的const和constexpr关键字可以用于定义常量，避免了宏定义常量的麻烦，并且提供了**类型安全和编译期计算**的优势。
- *内联函数*：C++的内联函数可以取代宏，以提高代码的可读性和类型安全性。内联函数在**编译**时展开，避免了宏带来的副作用和类型不匹配的问题。
- *模板*：模板是C++的强大特性之一，可以实现类型安全的泛型编程。通过模板，可以避免使用宏进行代码的泛化。
### 为什么使用内联函数？需要注意什么？
> 使用内联函数可以提高代码的执行效率，减少函数调用的开销。 使用内联函数的主要目的是减少函数调用的开销

- 内联函数是指在函数声明前加上`inline`关键字的函数，它的作用是告诉编译器在调用函数的地方直接将**函数体插入**，而不是通过函数调用的方式执行。
- 因为函数的调用会涉及栈帧的创建和销毁、参数传递等操作，而将函数体直接插入调用点则无需进行这些操作。

*需要注意的点*
- 内联函数适用于**函数体简单、调用频繁**的情况。如果函数体较大或调用频率较低，使用内联函数可能会导致==代码膨胀==，产生更多的代码复制，甚至可能导致性能下降。
- 内联函数的声明通常放在头文件中，因此需要注意内联函数的*定义和声明应该一致*，遵循内联函数的定义规则，在同一个编译单元中只能有一个定义。
- ==虚函数==不能使用内联函数，因为虚函数的调用是通过**虚表**进行的，无法在**编译时**确定调用的具体函数。
### 简述C++从代码到可执行二进制文件的过程
- *预处理（Preprocessing）*：预处理器（如cpp）会处理源代码文件，**展开宏定义**、处理**条件编译指令**等，并生成一个被称为"翻译单元"（translation unit）的中间文件。
- *编译（Compilation）*：编译器（如gcc、clang等）将预处理产生的翻译单元转化为==汇编代码（Assembly Code）==。这个阶段将源代码的高级语言表示转化为底层的汇编指令。
- *汇编（Assembly）*：汇编器（如as）将汇编代码转化为机器码的==目标文件（Object File）==。目标文件中包含了可执行程序的机器指令，但还没有进行最终的链接。
- *链接（Linking）*：链接器（如ld）将目标文件与所需的库文件进行链接，解析符号引用，生成最终的==可执行二进制文件==。这个阶段还包括地址分配、符号解析、重定位等操作，确保不同目标文件之间的引用关系正确。
### 继承和虚继承
> 继承是面向对象编程中的一个重要概念，它允许一个类（派生类或子类）继承另一个类（基类或父类）的属性和方法。通过继承，派生类可以重用基类的代码，并可以在此基础上进行扩展和修改
#### 公有继承（public inheritance）
> 使用`public`关键字来指定**基类**与**派生类**之间的继承关系。公有继承表示派生类可以访问基类的公有成员。

#### 保护继承（protected inheritance）
> 使用`protected`关键字来指定基类与派生类之间的继承关系。保护继承表示派生类可以访问基类的公有和保护成员。

#### 私有继承（private inheritance）
> 使用`private`关键字来指定基类与派生类之间的继承关系。私有继承表示派生类可以访问基类的公有和保护成员。

#### 虚继承（virtual inheritance）
> 是处理**多重继承**下的*二义性*问题的一种机制。当一个派生类通过不同的路径继承自同一个基类时，使用虚继承可以**确保只有一个基类子对象被创建**。
```c++
	class Base {
	public:
	    int x;
	};
	
	class Derived1 : public virtual Base {
	public:
	    int y;
	};
	
	class Derived2 : public virtual Base {
	public:
	    int z;
	};
	class Derived3 : public Derived1, public Derived2 {
	public:
	    int sum;
	};
	在这个例子中，Derived3类通过虚继承方式从Derived1和Derived2类继承Base类，确保只有一个Base子对象被创建，避免了多个实例的问题。
```
### 多态的类，内存布局是怎么样的
#### 多态定义
> 多态是面向对象编程的一个重要特性，它允许我们使用**基类指针**或**引用**来操作派生类对象，并在==运行时==根据对象的实际类型调用正确的成员函数。

> 在多态的情况下，每个类都有一个**虚函数表**（`vtable`），这个表存储了类的虚函数的地址。
- 当一个类具有虚函数时，编译器会将一个指向虚函数表的指针（通常称为虚函数指针或`vptr`）添加到类的对象中。
#### 多态类的内存布局#### 多态类的内存布局
内存布局取决于编译器和操作系统的具体实现，下面是一个常见的内存布局示例说明（以单继承为例）
```c++
class Base {
public:
    virtual void func1();
    virtual void func2();
private:
    int x;
};

class Derived : public Base {
public:
    virtual void func1();
    void extraFunction();
private:
    int y;
};
```
在这个例子中，Base类和Derived类都包含了虚函数并且派生关系是公有继承。假设在`32`位系统中。

- 对于Base类的对象，其内存布局如下：
``` c++
-----------------------------------
| vptr (4 bytes) | x (4 bytes)    |
-----------------------------------
```
`Base`类的对象包含一个指向虚函数表的指针 `vptr` 和 `x` 成员变量。

- 对于`Derived`类的对象，其内存布局如下：
```c++
--------------------------------------------------------
| vptr (4 bytes) | x (4 bytes)    | y (4 bytes)          |
--------------------------------------------------------
```
`Derived`类的对象也包含一个指向虚函数表的指针 `vptr`，以及继承自`Base`类的 `x` 成员变量和 `Derived`类自己的 `y` 成员变量。

虚函数表（`vtable`）存储在类的只读数据段中。`vptr` 指针指向了这个表，通过这个指针，程序可以在**运行时**动态地获取正确的虚函数来调用。
#### 多态实现的三个条件
- *继承关系*：存在基类（父类）和派生类（子类）之间的继承关系。
- *虚函数*：基类中被派生类**重写**的函数必须被**声明**为虚函数。使用`virtual`关键字来定义虚函数。
- *基类指针或引用*：利用**基类指针**或**引用**来指向派生类的对象，从而实现函数的动态绑定。
#### 多态实现原理
> 当基类指针或引用调用一个虚函数时，会发生动态绑定。实际调用的函数取决于指针或引用所指向的对象的类型。

- 每个虚函数在类的**虚函数表**（`vtable`）中有一个条目，该表是一个由编译器维护的静态表格。
- 每个对象（实例）通过一个指向其所属类的虚函数表的**虚函数指针**（`vptr`）来引用相应的虚函数表。
- 虚函数的调用是通过==间接寻址==来实现的，即通过使用对象的虚函数指针（`vptr`）找到所对应的虚函数表，并从表中获取相应的函数地址进行调用。
- 在运行时，通过指针或引用访问虚函数时，编译器会根据对象的实际类型，通过虚函数指针找到对应的虚函数表，然后根据函数名或索引在虚函数表中查找相应的函数地址进行调用。
### 被隐藏的基类函数如何调用？子类怎么调用父类的同名函数和父类成员变量？
#### 调用父类的同名函数
> 使用基类名加上**作用域解析运算符**来调用父类的同名函数
```c++
class Base {
public:
    void function() {
        cout << "This is the Base class function" << endl;
    }
};

class Derived : public Base {
public:
    void function() {
        cout << "This is the Derived class function" << endl;
    }

    void callBaseFunction() {
        Base::function(); // 调用父类的同名函数
    }
};

Derived d;
d.function(); // 调用子类的同名函数
d.callBaseFunction(); // 调用父类的同名函数
在上述示例中，Derived类中定义了一个与Base类同名的函数function。通过使用Base::function()，我们可以在子类中调用父类的同名函数。
```
#### 访问父类的同名成员变量
> 可以使用**作用域解析运算符**来访问父类的同名成员变量。
```c++
class Base {
public:
    int x;

    void print() {
        cout << "Base x: " << x << endl;
    }
    
};

class Derived : public Base {
public:
    int x;

    void print() {
        cout << "Derived x: " << x << endl; // 访问子类的同名成员变量
        cout << "Base x: " << Base::x << endl; // 访问父类的同名成员变量
    }
};

Derived d;
d.x = 10;
d.Base::x = 20;
d.print();
在上述示例中，Derived类和Base类都定义了一个同名的成员变量x。通过使用Base::x，我们可以在子类中访问父类的同名成员变量。
```
### 拷贝构造函数
#### 拷贝构造函数作用及用途？
> 拷贝构造函数的作用是创建一个对象的**副本**。它在以下情况下被调用：
- *对象的复制*：当使用一个同类对象来初始化另一个同类对象时，拷贝构造函数被调用。例如，通过复制一个对象来创建一个新对象。
- *参数传递*：当将对象作为参数传递给函数时，拷贝构造函数用于创建参数的副本。
- *返回值*：当函数返回一个对象时，拷贝构造函数用于创建返回值的副本。
#### 什么时候需要自定义拷贝构造函数？
- *浅拷贝不够*：如果类中有==指针成员或资源==（如文件句柄）需要进行深度拷贝，以防止多个对象共享同一资源。否则，当一个对象销毁时，共享的资源可能会被释放，从而导致其他对象的资源变为无效。
- *防止浅拷贝*：如果类没有指针成员或资源，但是你希望*禁止*浅拷贝操作，以确保每个对象都有其自己的独立副本，**避免共享**相同的数据。
- *高效率要求*：有时候默认的拷贝构造函数可能不够高效，例如当类中有大量的数据或复杂的操作时。在这种情况下，自定义拷贝构造函数可以实现更高效的对象复制。
```c++
#include <iostream>

class MyClass {
public:
    int* data; // 指针成员

    // 默认构造函数
    MyClass() : data(nullptr) {}

    // 自定义拷贝构造函数
    MyClass(const MyClass& other) {
        // 执行深拷贝
        if (other.data != nullptr) {
            data = new int(*other.data);
        } else {
            data = nullptr;
        }
    }

    // 析构函数
    ~MyClass() {
        delete data; // 释放堆内存
    }
};

int main() {
    MyClass obj1;
    obj1.data = new int(10);

    MyClass obj2(obj1); // 使用拷贝构造函数进行深拷贝

    std::cout << *obj1.data << std::endl; // 输出: 10
    std::cout << *obj2.data << std::endl; // 输出: 10

    delete obj1.data;

    std::cout << *obj2.data << std::endl; // 输出: 10，仍然有效
    return 0;
}
上述代码中，MyClass类中包含了一个指针成员data。为了避免多个对象共享同一个内存资源，我们在拷贝构造函数中进行了深拷贝操作，即创建一个新的内存副本并将指针指向新的内存位置。这样，obj2对象将拥有独立的data指针和副本，而不会与obj1对象共享。至于析构函数中的delete操作，则用于释放堆内存，避免内存泄漏
```
### 析构函数
#### 析构函数可以抛出异常吗？为什么 ⭐

> **异常点之后的代码不会执行**：当析构函数抛出异常时，异常将导致程序流程跳转到异常处理代码，导致异常点之后的代码不会被执行。这可能会导致对象销毁过程中的必要动作无法执行，例如释放资源，从而引发**资源泄漏**等问题。

- *安全性*：抛出异常可能导致**资源泄漏**或不一致的状态。
- *可追踪性*：异常的发生会增加代码的复杂性和**调试**的困难。
- *可移植性*：不同**编译器**可能对析构函数中的异常支持不同。
#### 如果析构函数抛出异常，并且在异常点之后的程序不会执行，造成了资源泄漏等问题的解决方式

> 使用智能指针、分离资源管理、使用`try-catch`捕获异常

- *使用智能指针*：使用C++中的**智能指针**（如std::unique_ptr、std::shared_ptr）来管理资源，可以自动处理资源的释放，避免手动管理资源导致的错误和异常。智能指针的析构函数会自动释放资源，即使在析构函数中抛出异常，也可以保证资源的正常释放。
- *分离资源管理*：将资源的释放操作从析构函数中分离出来，使用独立的函数或类来管理资源的释放。在析构函数中调用这些资源管理函数，如果资源释放过程中发生异常，可以通过合适的方式处理异常，避免资源泄漏。
- *做好异常处理*：在析构函数中合理地使用异常处理机制，例如使用==try-catch==块捕获异常，并在catch块中适当地处理异常。这样可以保证即使在析构过程中发生异常，也不会导致程序崩溃或其他严重问题。
### 关键字
#### mutable和volatile关键字功能对比？
> mutable用于修改类的**成员变量**，以解除常量成员函数对变量修改的限制
> 而volatile用于标记可能发生变化的变量，告诉编译器需要特殊对待，以防止**编译器优化**导致的问题。

#### `mutable`关键字

- `mutable`关键字用于修饰**类的成员变量**，在*常量成员函数*中允许被修改。
- 默认情况下，常量成员函数不允许修改类的成员变量，而使用`mutable`关键字可以解除这个限制，允许在常量成员函数中修改被`mutable`修饰的成员变量。
- `mutable`关键字适用于一些**内部状态**需要在常量成员函数中更新的情况，例如*缓存结果或需要记录操作次数*等。

#### `volatile`关键字

- `volatile`关键字用于修饰变量，在**多线程**、**硬件IO**和**中断处理**等场景中，告诉编译器该变量的值是可能发生变化的，需要特殊对待。
- 为了告诉编译器不要对该变量进行优化，以防止对变量读取和写入的优化可能导致错误的行为。
- `volatile`适用于需要和外部环境进行交互的变量，比如**硬件寄存器**的状态、**多线程操作**的标记等。
### 栈溢出一般是由哪些原因导致？⭐
> 栈溢出是指程序在执行过程中，调用栈空间超过了栈的大小限制，导致向相邻的内存区域进行写操作，从而引发错误或崩溃。

- *递归调用*没有终止条件或递归层数过深。
- 函数中声明的*局部变量*过多或过大。
- *递归数据结构*中的递归层数过深。
- 使用了大量的*函数调用*，导致调用链过长。
- *异常处理*中的递归调用过深。
### 什么是字节对齐？为什么要字节对齐？⭐
> 在`C`语言中，结构是一种复合数据类型，它可以由基本数据类型（如`int`、`long`、`float`等）的变量和其他复合数据类型（如数组、结构、联合等）的数据单元组成。结构中的成员按照声明的顺序在内存中顺序存储

> 为了提高`CPU`对变量的访问效率，变量在内存中需要进行字节对齐

- *CPU访问效率*：对齐后的变量起始地址能够减少CPU访问内存的**次数**，提高数据的读取效率。特别是一些架构的CPU在访问未对齐的数据时可能会发生错误，导致程序出现异常。
- *节省存储空间*：合理的对齐可以避免因为填充空间带来的浪费。编译器在结构中的成员之间会插入一些*填充字节*，以保证下一个成员按照对齐规则进行存储。对齐后，填充空间的大小可以最小化，节省存储空间。
### 静态成员函数与普通成员函数的区别?⭐⭐
> **调用方式：**

- 静态成员函数可以直接通过==类名==来调用，无需创建类的对象。
- 普通成员函数必须通过类的对象或指针来调用。
```c++
class MyClass {
public:
    static void staticFunc() {
        // 静态成员函数的实现
    }

    void normalFunc() {
        // 普通成员函数的实现
    }
};

int main() {
    // 调用静态成员函数
    MyClass::staticFunc();

    MyClass obj;
    // 调用普通成员函数
    obj.normalFunc();

    return 0;
}
```

> **访问权限：**

- 静态成员函数只能直接访问*静态成员变量*和*静态成员函数*，不能直接访问非静态成员变量和非静态成员函数。
- 普通成员函数可以直接访问类的*所有成员*，包括静态成员和非静态成员。
```c++
class MyClass {
private:
    static int staticNum; // 静态成员变量
    int num; // 非静态成员变量

public:
    static void staticFunc() {
        // 静态成员函数可以访问静态成员变量
        staticNum = 10;

        // 编译错误，静态成员函数不能访问非静态成员变量
        // num = 20;
    }

    void normalFunc() {
        // 普通成员函数可以访问静态成员变量
        staticNum = 30;

        // 普通成员函数可以访问非静态成员变量
        num = 40;
    }
};

int MyClass::staticNum = 0;

int main() {
    MyClass obj;
    obj.normalFunc();

    // 静态成员函数可以直接访问静态成员变量
    MyClass::staticFunc();

    return 0;
}
```

> **存储方式：**

- 静态成员函数不会影响类的对象的大小，它们存储在类的命名空间中，所有对象共享同一个静态成员函数。
- 普通成员函数被存储在类的对象中，每个对象都有自己的成员函数。
```c++
class MyClass {
public:
    static void staticFunc() {
        // 静态成员函数的实现
    }

    void normalFunc() {
        // 普通成员函数的实现
    }
};

int main() {
    MyClass obj1, obj2;

    // 所有对象共享同一个静态成员函数
    MyClass::staticFunc();

    // 每个对象有自己的普通成员函数
    obj1.normalFunc();
    obj2.normalFunc();

    return 0;
}
```
> **this 指针：**

- 普通成员函数有一个隐含的指向当前对象的指针，即 `this` 指针，可以在函数中使用 `this` 指针访问对象的成员。
- 静态成员函数*没有* `thi`s 指针，无法直接访问非静态成员。
 ```c++
class MyClass {
private:
    int num; // 非静态成员变量

public:
    static void staticFunc() {
        // 静态成员函数没有 this 指针，无法访问非静态成员变量
        // num = 10;
    }

    void normalFunc() {
        // 普通成员函数可以通过 this 指针访问非静态成员变量
        this->num = 20;
    }
};

int main() {
    MyClass obj;
    obj.normalFunc();

    // 静态成员函数没有 this 指针，不能直接访问对象成员

    return 0;
}
```
> **类作用域：**

- 静态成员函数属于**类**的作用域，可以直接访问类的静态成员变量和静态成员函数，无需通过对象或指针。
- 普通成员函数属于**对象**的作用域，可以直接访问类的静态成员和非静态成员，需要通过对象或指针来访问。
 ```c++
class MyClass {
public:
    static int staticNum; // 静态成员变量

    static void staticFunc() {
        // 可以直接访问静态成员变量
        staticNum = 10;

        // 可以直接调用静态成员函数
        staticFunc();
    }

    void normalFunc() {
        // 可以直接访问静态成员变量
        staticNum = 20;

        // 可以直接访问非静态成员变量
        num = 30;
    }

    int num; // 非静态成员变量
};

int MyClass::staticNum = 0;

int main() {
    // 静态成员函数可以直接访问静态成员变量和静态成员函数
    MyClass::staticFunc();

    MyClass obj;
    // 普通成员函数需要通过对象访问静态成员变量和静态成员函数
    obj.normalFunc();

    return 0;
}
```
### 为什么静态成员函数不能访问非静态成员？⭐
> 静态成员函数并不隶属于任何具体的对象，而是属于整个**类**。
> 这导致在静态成员函数中没有隐含的指向对象的 this 指针。
> 由于**非静态成员**是在**对象的上下文**中存在的，因此在没有对象的情况下，无法直接访问非静态成员。

> 要访问非静态成员，需要使用**对象或指针**进行访问
> 例如在静态成员函数内部通过对象调用非静态成员函数或访问非静态成员变量。
```c++
class MyClass {
public:
    static void staticFunc() {
        // 静态成员函数无法直接访问非静态成员变量和非静态成员函数
        // num = 10; // 错误：无法访问非静态成员变量
        // normalFunc(); // 错误：无法访问非静态成员函数
    }

    void normalFunc() {
        // 普通成员函数可以直接访问非静态成员变量和非静态成员函数
        num = 20;
        normalFunc2();
    }

private:
    int num; // 非静态成员变量

    void normalFunc2() {
        // 非静态成员函数可以直接访问非静态成员变量
        num = 30;
    }
};

int main() {
    MyClass obj;
    obj.normalFunc();

    // 静态成员函数无法直接访问非静态成员变量和非静态成员函数
    // MyClass::staticFunc(); // 错误：无法访问非静态成员变量和非静态成员函数

    return 0;
}
```

### 静态变量什么时候初始化？⭐
> 在C语言中，全局变量和静态变量的初始化发生在**编译**期。
```c 
#include <stdio.h>

int globalVar = 10; // 全局变量，在编译期初始化

void function() {
    static int staticVar = 20; // 静态变量，在编译期初始化
    printf("Static variable: %d", staticVar);
}

int main() {
    printf("Global variable: %d", globalVar);
    function();
    return 0;
}
```

> 在C++中，全局变量的初始化在程序的`main`函数执行之前完成，即在程序**启动时**就完成了初始化。
> 函数内的局部静态变量在**第一次调用**该函数时初始化，并且在函数调用结束后仍然保持其值，直到程序结束。
> 类中的静态成员变量在程序**启动**时初始化，类似于全局变量，但它们的作用域仅限于类。

### 命名空间
> 命名空间对于代码的可读性和维护性非常重要，在大型项目中应该充分利用它来避免名称冲突和提高代码的可读性。

- 命名空间使用关键字`namespace`来定义。
- 可以在命名空间中定义变量、常量、函数、类等。
- 通过“`::`”（作用域解析运算符）来访问命名空间中的成员，例如`namespace_name::member_name`。
- 也可以使用`using`声明语句将整个命名空间引入到当前作用域中，从而直接使用其中的成员，例如`using namespace namespace_name;`。
- 在一个文件中可以定义多个命名空间（只能在**全局**空间定义），并且一个命名空间可以**嵌套**在另一个命名空间内。
- C++标准库中的所有类和函数都被包含在了`std`命名空间中，因此在使用这些类和函数时需要加上`std`前缀，或者使用`using`声明语句将整个`std`命名空间引入到当前作用域中。
## 内存分配
- `new`操作符申请内存分配时，*无需指定*内存块的**大小**，编译器会根据类型信息自行计算。而malloc则需要显式地支持所需内存的大小。
- `new`操作符内存分配成功时，返回的是对象类型的**指针**，==类型严格与对象匹配==，无需进行类型转换，故new是符合类型安全性的操作符。而`malloc`内存分配成功则是返回`void*`，需要通过强制类型转换将void_指针转换成我们需要的类型。
- `new`内存分配失败时，会抛出`bad_alloc`异常。`malloc`分配内存失败时返回`NULL`

| 特性        | `new`                 | `malloc`             | `calloc`             |
| --------- | --------------------- | -------------------- | -------------------- |
| *语法*      | `C++` **操作符**         | C 语言库函数              | C 语言库函数              |
| *类型安全*    | 自动计算所需内存大小，类型匹配       | 手动计算内存大小，需要强制类型转换    | 手动计算元素数量和大小，需要强制类型转换 |
| *返回类型*    | 对象类型指针                | `void*`（需要类型转换）      | `void*`（需要类型转换）      |
| *构造/析构函数* | 自动调用**构造函数**          | 不调用构造函数，内存未初始化       | 不调用构造函数，内存初始化为全`0`   |
| *内存初始化*   | -                     | 内存未初始化（可能含有随机值）      | 内存初始化为全 0            |
| *内存分配失败*  | 异常机制检测内存分配失败          | 分配失败返回 `NULL`，需要手动检查 | 分配失败返回 `NULL`，需要手动检查 |
| *重载与自定义*  | 可以重载，并与自定义类型构造/析构函数配合 | 不会调用自定义类型构造/析构函数     | 不会调用自定义类型构造/析构函数     |

### new与malloc使用区别
```c++
#include <iostream>
#include <cstdlib>

int main() {
    // 使用new进行动态内存分配和释放
    int* newPtr = new int(10);
    std::cout << "Value allocated with new: " << *newPtr << std::endl;
    delete newPtr;

    // 使用malloc进行内存分配和释放
    int* mallocPtr = (int*)malloc(sizeof(int));
    if (mallocPtr != nullptr) {
        *mallocPtr = 20;
        std::cout << "Value allocated with malloc: " << *mallocPtr << std::endl;
        free(mallocPtr);
    }

    return 0;
}
```
### malloc(0)
> `malloc(0)` 是合法的，但它分配了一个大小为`0`的内存区域，这意味着你不能通过返回的指针来访问任何数据。

> 当你执行 `char *ptr = malloc(0);` 时，会发生以下情况：
- *内存分配*：`malloc` 尝试分配0字节的内存。根据C标准，请求分配0字节的内存是合法的，并且 `malloc` 应该成功返回一个非空指针。
- *返回值*：即使请求的大小是0，`malloc` 也会返回一个有效的指针。这个指针指向的内存块大小为0，也就是说，它实际上不指向任何可访问的内存空间。
- *使用限制*：尽管返回了一个指针，但由于分配的大小为0，你不能通过这个指针读写任何数据。任何尝试解引用这个指针（即访问 `*ptr`）的操作都是未定义行为。
- *内存释放*：尽管分配的大小为0，你仍然可以（并且应该）在不再需要时使用 `free(ptr)` 来释放内存。即使对于大小为0的分配，这也是一个好的编程实践。
- *性能考虑*：在某些系统上，`malloc(0)` 可能返回一个指向特定区域的指针，而不是进行实际的内存分配。这是为了优化性能，因为0字节分配的开销可能不值得。
- *移植性*：虽然C标准保证了 `malloc(0)` 的行为，但是具体的实现可能会有所不同。在不同的系统或不同的内存分配器上，返回的指针可能指向不同的地址。
### malloc 原理
#### 定义
> `malloc` 函数的原型如下：
```c
void *malloc(size_t size);
```

- 当开辟的空间小于 `128K` 时，调用 `brk()`函数，`malloc` 的底层实现是系统调用函数`brk()`，其主要移动指针 `_enddata`(此时的` _enddata` 指的是 `Linux` 地址空间中**堆段**的*末尾地址*，不是数据段的末尾地址)
- 当开辟的空间大于 `128K` 时，`mmap()`系统调用函数来在**虚拟地址空间**中（堆和栈中间，称为*文件映射区域*的地方）找一块空间来开辟。
#### 具体实现
- 当调用 `malloc(size)` 时，它首先计算需要分配的内存块大小，包括用户请求的大小以及内存管理所需的额外空间（例如*内存块的管理信息*）。
- `malloc` 会遍历一个数据结构（例如空闲链表或空闲块列表），查找合适大小的**空闲内存块**。
- 如果找到了合适的内存块，`malloc` 会将其标记为已分配，并返回一个指向该内存块的指针给用户。
- 如果没有足够大的空闲内存块可用，`malloc` 可能需要扩展程序的虚拟内存空间。它通过系统调用（例如 `brk` 或 `mmap`）向操作系统请求更多的*连续*内存空间。`brk` 调整进程数据段的末端位置，而 `mmap` 则可以映射文件或创建匿名映射，后者通常用于动态内存分配。
- 当堆的顶部区域（`top chunk`）变得足够大时，可能会触发 `brk` 紧缩（`shrink`），这使得操作系统回收部分未使用的内存。然而，`brk` 紧缩并不是由 `malloc` 自动触发的，而是需要特定条件下才会发生。
- 当操作系统提供了更多的内存空间后，`malloc` 可以从新的空间中分配出合适大小的内存块，并将其标记为*已分配*。
- 在内存块被释放时，通过调用 `free` 函数，`malloc` 将其标记为未分配，并将该内存块添加到*空闲内存块的列表*中，以便后续的内存分配可以重复使用它们。
#### 简易代码实现
```c
#include <unistd.h>   // 包含系统调用相关的头文件

typedef struct Block {
    size_t size;       // 内存块的大小
    struct Block* next; // 指向下一个内存块的指针
} Block;

Block* freeList = NULL;   // 空闲链表的头指针

void* malloc(size_t size) {
    // 检查参数是否合法
    if (size <= 0) {
        return NULL;
    }
    
    // 计算需要分配的内存大小
    size_t blockSize = sizeof(Block) + size;
    
    // 在空闲链表中查找符合要求的内存块
    Block* prevBlock = NULL;
    Block* currBlock = freeList;
    while (currBlock != NULL) {
        if (currBlock->size >= blockSize) {
            // 找到合适大小的空闲块
            if (prevBlock != NULL) {
                // 删除这个空闲块
                prevBlock->next = currBlock->next;
            } else {
                // 这个空闲块是链表的头节点
                freeList = currBlock->next;
            }
            
            // 返回指向内存块的指针
            return (void*)(currBlock + 1);
        }
        prevBlock = currBlock;
        currBlock = currBlock->next;
    }
    
    // 没有找到可用的内存块，请求更多内存空间
    Block* newBlock = sbrk(blockSize);
    if (newBlock == (void*)-1) {
        return NULL;   // 请求失败，返回 NULL
    }
    
    // 返回指向新内存块的指针
    return (void*)(newBlock + 1);
}

void free(void* ptr) {
    // 检查参数是否合法
    if (ptr == NULL) {
        return;
    }
    
    // 获取指向内存块起始位置的指针
    Block* block = ((Block*)ptr) - 1;
    
    // 将内存块标记为未分配状态，然后将其添加到空闲链表中
    block->next = freeList;
    freeList = block;
}
```
### new底层实现
#### 1.调用 `operator new`分配内存
程序首先会调用全局或自定义的 `operator new` 函数来分配足够的内存。
```c++
/*operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，尝试执行空 间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。*/
void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc){ 
	// try to allocate size bytes 
	void *p; 
	while ((p = malloc(size)) == 0) 
	if (_callnewh(size) == 0) 
	{ 
		// report no memory 
		// 如果申请内存失败了，这里会抛出bad_alloc 类型异常
		static const std::bad_alloc nomem; 
		_RAISE(nomem); 
	} 
	return (p);
}
```
#### 2.计算内存大小
`new` 会根据所分配对象的类型计算出需要分配的内存大小。

- 对于简单类型（如 `int` 或 `float`），内存大小是类型的固定大小。
- 对于类对象，还需要考虑类的成员变量和内存对齐。
#### 3. 调用构造函数
在成功分配内存后，`new` 运算符会**调用对象的构造函数**来初始化该对象。

- 如果分配的是类对象，`new` 会调用该类的构造函数，并将分配的内存指针传递给构造函数，初始化类的成员变量。
- 如果分配的是数组，`new` 会为每个元素依次调用构造函数。
#### 4. 返回指针
`new` 运算符在成功分配内存并构造对象后，会返回指向该内存的指针。
对于 `new[]` 运算符（用于分配数组），还需要额外的步骤来跟踪数组的大小，因为数组中的每个元素都需要分别调用构造函数。
#### 5. 错误处理：异常情况：
如果内存分配成功，但对象的构造函数抛出异常，`new` 会自动**释放已分配的内存**，避免内存泄漏。具体来说：

- 内存分配失败时，会抛出 `std::bad_alloc` 异常（默认情况下）。
- 如果构造函数抛出异常，已分配的内存会被释放。