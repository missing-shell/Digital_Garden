### 虚函数可以是模板函数吗？⭐
> 虚函数不可以是模板函数，只有普通的成员函数可以模板化。

- *模板函数*的实例化是在编译器**编译**整个程序期间发生的
- 虚函数的调用是在**运行时**才确定的。
- 对于含有虚函数的类，编译器需要为每个类生成一个虚函数表（`vtable`），以便在运行时进行**动态绑定**。
- 虚函数表中存储着该类的虚函数的*地址*。
- 而模板函数的实例化个数是在整个程序被编译完成之后才确定的，编译器无法为模板函数生成固定数量的虚函数表。
### 请你说说虚函数的工作机制⭐⭐⭐
> 虚函数的实现方式通常包括在对象中添加一个指向虚函数表的指针（`vptr`），**虚函数表**存储了虚函数的地址，子类继承并重写父类的虚函数时会替换相应的地址，通过 `vptr` 指针和虚函数表来实现动态绑定和多态。虚函数的实现会带来额外的内存访问开销。

- 在有虚函数的类中，当类实例化为对象时，会在对象的内存布局中添加一个指向虚函数表的指针。这个指针通常位于对象最开始的位置，也就是对象的 `vptr`（虚表指针）。
- 虚函数表是一个静态的表格，保存了类中所有虚函数的地址。这个虚函数表在内存中的位置通常是在代码段（`.text`）中，而不是在对象的实际内存中。
- 当子类继承了父类的时候，子类对象也会继承父类的虚函数表。
- 当子类重写（`override`）父类中的虚函数时，会将虚函数表中对应的函数地址替换为子类的虚函数地址，从而实现了动态绑定和多态。
- 运行时，通过对象的 `vptr` 指针来访问虚函数表，并根据表中存储的函数地址调用相应的虚函数。这个调用过程是动态的，会根据实际对象的类型来选择正确的虚函数实现。
- 虚函数的实现确实会增加访问*内存的开销*，因为需要通过 `vptr` 指针来访问虚函数表，并进行间接的函数调用。这可能会带来一些性能上的损失。对于不需要多态性的函数，可以选择将其声明为非虚函数，以提高性能。
### 虚函数表在什么时候创建？每个对象都有一份虚函数表吗？

- 虚函数表不用每个实例一份，**所有对象实例共享同一个虚函数表即可**。虚函数表是每个多态类一份，由编译器在**编译**时创建。
- 虚函数表是类级别的==静态成员==，存储了类中所有*虚函数的地址*。
- 每个对象中包含一个虚函数表指针（`vptr`），它指向了所属类的虚函数表。每个对象通过自己的虚表指针来访问类的虚函数表。
- 对象之间共享类的虚函数表，它们的虚表指针指向*同一个*虚函数表。
- 每个类的派生类继承了基类的虚函数表，并可以在派生类中扩展和重写虚函数。派生类的虚函数表会*包含基类*的虚函数，并添加派生类*自己的虚函数*。派生类的虚函数表会替代基类的虚函数表。
- 虚函数表只有一份，而有多少个**对象**，就对应多少个**虚函数表指针**。
### 操作符重载⭐⭐
#### 定义
> 操作符重载是一种特殊的函数重载，可以使得某些运算符在对**特定对象**进行操作时具有**自定义的行为**。

- 通过重载操作符，可以为*自定义*的*类类型*创建与内置类型相似的语法和行为。
```c++
#include <iostream>

class MyNumber {
private:
    int value;

public:
    MyNumber(int val) : value(val) {}

    MyNumber operator+(const MyNumber& other) {
        return MyNumber(value + other.value);
    }

    int getValue() const {
        return value;
    }
};

int main() {
    MyNumber num1(5);
    MyNumber num2(10);

    MyNumber sum = num1 + num2;

    std::cout << "The sum is: " << sum.getValue() << std::endl;
    
    return 0;
}
```
#### 哪些操作符不能重载
- 成员选择操作符（`.`）：无法改变点操作符的行为。
- 作用域解析运算符（`::`）：它用于指定作用域，不能被重载。
- 条件运算符（`?:`）：无法改变条件运算符的行为。
- `sizeof`：它是一个关键字，无法重载。
- `typeid`：它是一个运算符，无法重载。
### 什么是纯虚函数⭐
> 纯虚函数（`Pure Virtual Function`）是在**基类**中声明但没有提供实现的虚函数。它的声明形式为在函数原型后面加上`= 0`。

> 纯虚函数在基类中起到以下作用：
- *提供接口定义*：纯虚函数在基类中定义了一种接口，规定了派生类*必须实现*的函数。基类通过纯虚函数定义了一组可供派生类实现的操作，从而实现了接口的定义。
- *实现多态性*：派生类可以根据自己的需要对纯虚函数进行重写，具体的实现可以根据派生类的特性和需求而自由定义，从而实现了多态性的特征。通过**基类指针**或**引用**调用纯虚函数，可以在运行时根据指针或引用所指向的实际对象类型来调用对应的派生类的实现。
```c++
#include <iostream>

// 基类定义
class Base {
public:
    // 纯虚函数
    virtual void pureVirtualFunc() const = 0;
};

// 派生类1实现纯虚函数
class Derived1 : public Base {
public:
    void pureVirtualFunc() const override {
        std::cout << "Derived1: Implementing pure virtual function" << std::endl;
    }
};

// 派生类2实现纯虚函数
class Derived2 : public Base {
public:
    void pureVirtualFunc() const override {
        std::cout << "Derived2: Implementing pure virtual function" << std::endl;
    }
};

int main() {
    Derived1 d1;
    Derived2 d2;

    // 通过基类指针调用派生类的实现
    Base* basePtr1 = &d1;
    basePtr1->pureVirtualFunc();

    Base* basePtr2 = &d2;
    basePtr2->pureVirtualFunc();

	// 通过派生类指针直接调用

    Derived1* derivedPtr1 = &d1;
    derivedPtr1->pureVirtualFunc();  

    Derived2* derivedPtr2 = &d2;
    derivedPtr2->pureVirtualFunc();   

    return 0;
}
```
### 虚函数可以内联吗？⭐
> 虚函数不能直接被标记为内联函数，因为虚函数在运行时通过虚函数表进行调用，而内联函数需要在**编译**时进行替换，两者的机制是不相容的。

### 析构函数与虚函数⭐⭐⭐
#### 析构函数一般写成虚函数的原因
- *多态性支持*：通过将析构函数声明为虚函数，可以实现指向派生类对象的基类指针或引用在运行时调用正确的析构函数。这样做可以确保**派生类**的析构函数得到调用，从而正确地*清理派生类所分配的资源*，而不仅仅是基类部分的资源。
- *动态绑定*：当基类指针或引用指向派生类对象时，将析构函数声明为虚函数可以实现动态绑定，即在运行时根据对象的类型选择正确的函数实现。如果析构函数不是虚函数，当删除一个基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类对象的资源没有得到正确释放，引发**资源泄漏**问题。
#### 构造函数为什么一般不定义为虚函数
- 虚函数的调用依赖于*对象的类型*，而在构造函数执行期间，对象的==类型==尚未完全确定。构造函数的目的是**初始化对象**，而不是多态性的实现。
- 在构造函数执行期间，对象的虚函数表（`vtable`）尚未被填充。因此，如果将构造函数声明为虚函数，虚函数调用将无法正确地解析到派生类的实现，因为派生类的虚函数表尚不存在。
#### 构造函数或析构函数中调用虚函数会怎样
> 构造函数和析构函数中调用虚函数的实际执行版本是根据**当前类的类型**决定的，无论对象的动态类型是什么。
- 构造函数中虚函数的调用会使用*当前类的实现*，即使被派生类重写了该虚函数。
- 析构函数中虚函数的调用也会使用*当前类的实现*，即使该对象被派生类实例化。在析构函数期间，对象的动态类型已经丧失，只能使用当前类的实现，因为派生类的部分已经被销毁。
- 这也是为什么在构造函数和析构函数中*调用*虚函数被视为一种不良实践，可能导致*未定义的行为*或意外的结果。应尽量避免在构造函数和析构函数中调用虚函数，或者在其中调用的虚函数应当被标记为`final`，以防止在派生类中被重写。
### 多重继承的二义性⭐
> 多重继承的二义性是指当一个类从多个父类继承同名成员时，可能会产生歧义，编译器无法确定应该访问哪个成员。

- 使用限定作用域符（`::`）指明访问特定父类的成员，即通过*父类名*加上作用域解析运算符来指定成员的访问。
- 使用虚拟继承（`virtual inheritance`），通过在派生类和共同基类之间建立虚拟继承关系，确保只有一个共享基类子对象，从而*消除二义性*。
- 在派生类中*重新定义*成员函数，以覆盖同名成员函数，并*明确指定*使用哪个父类的实现。
### 可以通过引用实现多态吗？⭐
> 可以通过引用实现多态。
- 多态是面向对象编程的一个重要概念，它允许使用*基类类型*的引用或指针来引用派生类对象，并根据实际对象的类型来调用相应的成员函数。
```c++
#include <iostream>

class Animal {
public:
    virtual void makeSound() const {
        std::cout << "Animal makes a sound.";
    }
};

class Dog : public Animal {
public:
    void makeSound() const override {
        std::cout << "Dog barks.";
    }
};

class Cat : public Animal {
public:
    void makeSound() const override {
        std::cout << "Cat meows.";
    }
};

int main() {
    Dog dog;
    Cat cat;

    // 使用基类类型的引用，实现多态
    Animal& animal1 = dog;
    Animal& animal2 = cat;

    animal1.makeSound();  // 输出：Dog barks.
    animal2.makeSound();  // 输出：Cat meows.

    return 0;
}

```
