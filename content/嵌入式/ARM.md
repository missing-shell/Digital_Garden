### 指令集 ⭐⭐⭐
#### 精简指令集 (RISC)
> 精简指令集 (`Reduced Instruction Set Computing`) 具有**简洁**、精简的指令集，每条指令执行的操作都很基础，使得处理器设计更简单。
- RISC 处理器通常需要*更多的指令*来完成复杂的操作，但每条指令执行的时间相对较短。
- 采用**固定长度**的指令格式，简化了指令译码的工作，提高了流水线执行效率。
- RISC 处理器倾向于通过==增加寄存器数量==来加速运算，以*减少内存访问*的频率。
#### 复杂指令集 (CISC)

> 复杂指令集 (`Complex Instruction Set Computing`) 包含大量复杂的指令，每条指令可以完成更多的工作，包括**访存、运算**等。
- `CISC` 处理器的指令通常更多样化，能够在一条指令内完成复杂的操作，因此每次执行的*指令数较少*。
- 具有**可变长度**的指令格式，使得指令译码较为复杂，执行速度可能会受到影响。
- `CISC` 处理器在设计上倾向于通过==多种复杂的指令==来*减少内存访问次数*，以提高程序的执行效率。
#### 精简指令集和复杂指令集对比

| 指令数量   | 较多          | 较少     |
| ------ | ----------- | ------ |
| 指令复杂度  | 简单          | 复杂     |
| 指令执行时间 | 短           | 长      |
| 指令格式   | 固定长度        | *可变*长度 |
| 寄存器的作用 | 重要，*减少内存访问* | 相对不太重要 |
#### ARM指令集类型

| 类型                                      | 动作                                                                                                        | 作用                             |
| --------------------------------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------ |
| 数据处理指令(`Data Processing Instructions`)  | 执行加减乘除等数学运算，以及位与（AND）、位或（OR）、位异或（XOR）等逻辑运算。                                                               | 对寄存器中的数据进行算术*运算*、逻辑运算、移位操作等。   |
| 加载/存储指令(`Load/Store Instructions`)      | 包括加载字（Load Word）、半字（Load Halfword）、字节（Load Byte）等不同大小的数据。                                                 | 从内存中加载数据到寄存器或将寄存器中的数据*存储*到内存中。 |
| 分支和跳转指令(`Branch and Jump Instructions`) | 根据条件进行分支跳转（Conditional Branching），或无条件地改变程序计数器（Program Counter, PC）的值以实现跳转到指定地址（Unconditional Jumping）。   | 改变程序的*执行流程*。                   |
| 控制指令(`Control Instructions`)            | 切换处理器模式，如中断模式（Interrupt Mode）、用户模式（User Mode）、特权模式（Privileged Mode）等；启用和禁用中断（Interrupts）、异常（Exceptions）等。 | *控制*处理器的操作模式、中断使能、异常处理和处理器状态等。 |
| 协处理器指令(`Coprocessor Instructions`)      | 主要用于执行浮点运算（Floating-point Operations）、加速加密算法（Cryptographic Algorithms）等特定的计算和处理任务。                        | 与附加协处理器进行*交互*，执行特定的协处理器操作。     |
### ARM和DSP有什么区别⭐

| 特征        | ARM处理器                                  | DSP处理器                   |
| --------- | --------------------------------------- | ------------------------ |
| *应用领域*    | **通用**处理器，用于控制和应用处理                     | 专用于数字信号处理，如音频、视频、通信等     |
| *指令集*     | `RISC`架构                                | 固定点和浮点指令集                |
| *主要功能*    | 通用处理器，适合通用用途的计算和控制                      | 专用于数字信号处理和算法加速           |
| *算术/逻辑单元* | 用于通用计算                                  | 专注于信号处理的算术逻辑单元           |
| *浮点运算*    | 适中支持浮点运算                                | 专注且高效的支持浮点运算             |
| *适用场景*    | 适合通用用途的处理器架构                            | 针对**信号处理**和**并行计算**优化的架构 |
| *架构*      | 通常采用冯·诺依曼架构，指令和数据共享同一存储器总线，但在存储器中是分开存储。 | 通常采用*哈佛架构*               |

### ARM架构
#### 定义
> `ARM`架构是一种**低功耗**、**高性能**以及成本效益高的处理器架构
> 由`ARM Holdings`开发并广泛应用于**移动设备**、嵌入式系统和其他领域。
#### 特点
- *低功耗*：`ARM`架构专注于**低功耗**设计，可延长电池寿命并减少能源消耗。它在使用功耗管理技术和优化设计方面表现出色。
- *强大的性能*：尽管低功耗设计，`ARM`架构仍能提供强大的性能，多核处理器的设计使其适应多线程应用。
- *灵活性*：`ARM`架构是**可定制**的，可以根据不同的需求进行配置，并且适用于各种应用，从移动设备到网络设备和汽车。
- *易于集成*：`ARM`架构的处理器芯片可以与其他硬件和软件组件轻松集成，使其成为系统设计的理想选择。
- *跨平台兼容性*：`ARM`架构具有广泛的**兼容性**，可以在不同的操作系统和平台上运行，例如`Android`、`iOS`、`Windows`等。
#### 常见架构对比

| **芯片架构** | **特点与优势**                           | **应用领域**          |
| -------- | ----------------------------------- | ----------------- |
| ARM      | - 低功耗、*高性能*<br>- 灵活可定制<br>- 广泛*兼容性* | 移动设备、嵌入式系统、物联网设备等 |
| RISC-V   | - *开放*、可定制<br>- 逐渐获得关注              | 低功耗嵌入式、物联网设备等     |
| MIPS     | - *高性能*和低功耗<br>- 嵌入式系统领域应用广泛        | 嵌入式系统、网络设备等       |
| x86      | - 高性能<br>- 生态系统成熟<br>- 处理复杂计算任务     | PC、服务器等           |
| Power    | - 强大的计算性能<br>- 可靠性高                 | 高性能计算、服务器、超级计算机等  |
### ARM处理器模式
#### 分类⭐⭐⭐⭐⭐

| **模式**           | **意义**                     | **类型**  | **说明**      |
| ---------------- | -------------------------- | ------- | ----------- |
| 用户模式（`usr`）      | `ARM`处理器正常的程序执行状态          | *非特权模式* | 用于普通的应用程序执行 |
| 系统模式（`sys`）      | 运行具有特权的操作系统任务              | 特权模式    | 普通模式        |
| 快速中断模式（`FIQ`）    | 处理*高速数据传输*或通道处理            | 特权模式    | 异常模式        |
| 外部中断模式（`IRQ`）    | 处理通用的中断请求                  | 特权模式    | 异常模式        |
| 管理模式（`svc`）      | 操作系统使用的*保护模式*              | 特权模式    | 异常模式        |
| 数据访问中止模式（`abt`）  | 处理数据或指令预取中止的情况，用于虚拟存储及存储保护 | 特权模式    | 异常模式        |
| 未定义指令中止模式（`und`） | 处理未定义指令的情况，支持硬件协处理器的软件仿真   | 特权模式    | 异常模式        |
#### 模式切换方式⭐⭐⭐⭐⭐

| 触发方式         | 切换流向                                        | 作用                                     |
| ------------ | ------------------------------------------- | -------------------------------------- |
| 软中断（`SWI`）指令 | 用户模式-->管理模式                                 | 执行特权级别的任务和系统功能                         |
| 外部中断         | -->`IRQ`/`FIQ`                              | 处理相应外部事件                               |
| 异常           | 内存方位异常 -->`Abort`模式<br>无效指令-->`Undefined`模式 | 处理异常                                   |
| 编写指令进入       | -->`Systerm`模式                              | 通过`SWI`进入`svc`模式，后进入`Systerm`执行特定系统级任务 |
#### ARM架构异常处理机制⭐⭐⭐
> `ARM`处理器的异常处理机制是一种用于处理==预定义==异常事件的机制。
- 在ARM架构中，有多种类型的**异常**，包括中断、故障和终止等。
- 异常处理机制通过提供一组*特殊的处理模式*和*相关的寄存器*来处理这些异常。
##### 异常处理流程
- *异常模式切换*：当异常事件发生时，处理器会从当前执行的模式（通常是用户模式或特权模式）切换到异常模式。常见的异常模式包括中断模式、中止模式、供货模式等。
- *异常发生和保存上下文*：在异常模式下，处理器会保存当前的程序状态寄存器（PSR）和一些关键的寄存器，以备将来恢复执行。这样可以确保在处理异常时不会丢失重要的执行状态。
- *异常处理*：处理器根据异常类型和相应的==异常向量表==，定位到相应的异常处理程序的入口点。异常处理程序可以是操作系统内核、中断服务例程或其他定义的处理代码。处理程序执行与异常相关的操作，如中断服务例程处理中断请求、故障处理程序处理异常条件等。
### ARM寄存器

| **寄存器标识**           | **名称**            | **具体作用**                                                                                       |
| ------------------- | ----------------- | ---------------------------------------------------------------------------------------------- |
| `R0~R12`            | 通用寄存器（包含`R0~R15`) | 存储数据和地址                                                                                        |
| R13 (`SP`)          | 堆栈指针寄存器           | 用作*堆栈指针*，存储当前**堆栈顶部**的地址。在函数调用时用于存储局部变量和参数（*压栈*和*出栈*）                                          |
| R14 (`LR`)          | 链接寄存器             | 存储调用*子程序*时的**返回地址**，用于在子程序执行完毕后返回到调用函数的下一条指令。                                                  |
| R15 (`PC`)          | 程序计数器寄存器          | 存储下一条要执行的指令的地址，==指示当前执行的指令位置==。                                                                |
| `CPSR`              | 程序状态寄存器           | 存储当前处理器的状态信息，如*当前模式*、条件标志位、*中断使能位*等。用于程序状态的管理和控制。                                              |
| `SPSR`              |                   | 保存*上一个模式下*的**程序状态寄存器**的值，用于在异常处理或者中断处理时保存先前的程序状态寄存器信息。                                         |
| `Control Registers` | 控制寄存器             | 用于处理器的控制和配置，包括处理器模式切换、中断控制等。                                                                   |
| `IMR`<br>`IRR`      | 中断相关寄存器           | 用于*管理*和*控制*中断，包括中断屏蔽寄存器 (`Interrupt Mask Register`)、中断优先级寄存器 (`Interrupt Priority Register`)等。 |
|                     | 浮点寄存器             | 用于*浮点运算*的特殊寄存器，存储浮点运算所需的数据和控制信息。                                                               |
| `VBAR`              | 向量表基址寄存器          | 存储中断向量表的地址，用于指示中断处理程序的入口地址。                                                                    |
### ARM汇编
#### 定义
> 以机器可读的指令形式直接操作计算机硬件，包括处理器寄存器、内存和输入输出端口等。

- ARM汇编语言的语法和指令集架构与具体的ARM处理器型号和指令集版本有关，但总体上它们都与ARM处理器的指令集架构密切相关。
#### 举例说明如何使用ARM汇编指令进行数据传输⭐⭐⭐
> 首先定义了一个数据段（.data），并在其中定义了两个32位的整型数据value1和value2。然后定义了一个代码段（.text），并指定入口点标签_start。在_start标签下，我们使用了LDR和STR指令来进行数据传输操作。

- LDR指令用于加载寄存器中的值，=value1表示将value1的地址加载到寄存器R0，=value2表示将value2的地址加载到寄存器R1。
- LDR指令还可以用于从内存中加载数据到寄存器，[R0]表示从R0寄存器所指向的地址处加载数据到R2寄存器。
- STR指令用于将寄存器中的值存储到内存，[R1]表示将R2寄存器中的数据存储到R1寄存器所指向的地址处。
```arm
.section .data     @ 定义数据段
value1:     .word 100      @ 定义一个32位的整型数据，并初始化为100
value2:     .word 0        @ 定义另一个32位的整型数据，初始化为0

.section .text     @ 定义代码段
.global _start      @ 定义入口点标签

_start:
    LDR R0, =value1   @ 将value1的地址加载到寄存器R0
    LDR R1, =value2   @ 将value2的地址加载到寄存器R1
    LDR R2, [R0]      @ 从内存地址R0处加载数据到R2
    STR R2, [R1]      @ 将R2中的数据存储到内存地址R1处

    MOV R7, #1       @ 设置系统调用号为1，表示退出程序
    SWI 0            @ 触发系统调用
```
