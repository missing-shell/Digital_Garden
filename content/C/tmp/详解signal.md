[[C专家编程#3.5 typedef可以成为你的朋友|signal详解]]

> [!分析signal]
> 在ANSI C标准中，signal()的声明如下:
> `void (*signal(int sig, void(*func)(int)))(int);`
>
> `void(*signal( ))(int);`
> `signal`是一个函数（具有一些令人胆战心惊的参数），它返回一个函数指针，后者所指向的函数接受一个int参数并返回void。其中一个参数是其本身：
> `void(*func)(int);`
> 它表示一个函数指针，所指向的函数接受一个int参数，返回值是void。

```c
typedef  void(*ptr_to_func) (int);

/*  
* 它表示ptr_to_func是一个函数指针，该函数接受一个int参数，返回值为void
*/
```

```c
ptr_to_func signal(int, ptr_to_func);

/*  它表示signal是一个函数，它接受两个参数，

- 其中一个是int，另一个是ptr_to_func，返回

- 值是ptr_to_func

  */
```

然而，说到typedef就不能不说一下它的缺点。它同样具有与其他声明一样的混乱语法，同样可以把几个声明器塞到一个声明中。

signal是一个函数（具有一些令人胆战心惊的参数），它返回一个函数指针，后者所指向的函数接受一个int参数并返回void。其中一个参数是其本身：`void(*func)(int);`它表示一个函数指针，所指向的函数接受一个int参数，返回值是void。现在，让我们看一下怎样用typedef来“代表”通用部分，从而进行简化。

---

这个声明涉及C语言中的函数指针和信号处理机制，看起来复杂，但我们可以一步步分解来理解它。声明可以分为几个部分：

1. **返回类型**：`void (*)(int)`，这表示返回的是一个指向函数的指针，该函数接受一个整型参数（`int`）并且不返回任何值（`void`）。
2. **函数名**：实际上，这里直接定义了一个函数指针变量，并没有命名一个具体的函数，所以没有传统意义上的“函数名”。但为了便于理解，你可以想象这部分是在定义一个能够接收和处理信号的功能接口。
3. **参数列表**：
    - `int sig`：表示该函数指针变量所指向的函数接受一个整型参数`sig`，这个参数代表信号的编号，如SIGINT（中断信号，通常对应Ctrl+C操作）。
    - `void(*func)(int)`：这是函数的第二个参数，也是一个函数指针，指向一个接受整型参数并返回`void`的函数。这个函数指针将作为信号处理函数，当特定信号发生时被调用。

4. **整体解读**：`void (*signal(int sig, void(*func)(int)))(int);`声明了一个名为`signal`的函数，它接受两个参数：一个是整数类型的信号编号`sig`，另一个是处理该信号的函数指针`void(*)(int)`。`signal`函数返回一个新的函数指针，这个返回的函数指针同样指向一个接受整型参数且无返回值的函数，即新的信号处理函数。简而言之，`signal`==函数用于注册或更改指定信号的处理方式，返回先前的信号处理函数指针以便恢复默认行为或链式处理。==

总结起来，这个声明定义了`signal`函数，它用于设置系统接收到特定信号时应执行的处理程序，同时允许保存并返回之前的信号处理函数指针，以便在需要时恢复。这是C语言中处理系统信号的标准方法之一。