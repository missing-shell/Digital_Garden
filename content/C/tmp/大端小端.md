> 对象为多字节数据。

在大端模式（Big-Endian）中，==多字节==数据的**最高字节**（最左边的字节）存储在**最低的内存地址**上，而最低字节（最右边的字节）存储在最高的内存地址上。在小端模式（Little-Endian）中，这个顺序是相反的。

给定的数组 `char test[8]` 包含8个字符，每个字符占用1字节。当将这个数组强制转换为 `int` 类型时，`int` 类型的大小通常取决于编译器和平台，但在32位系统中，它通常是4字节（32位）。

数组 `test` 的内容是：

```
0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
```

在大端模式下，将这个数组**强制转换**为 `int` 类型后，存储在内存中的顺序将是：

```
0x08, 0x07, 0x06, 0x05
```

这是因为 `int` 类型是4字节的，所以它会取数组的前4个字节，按照大端模式存储。因此，`test_p[1]` 实际上指向的是 `0x07`，它是 `int` 类型数据的第二个字节。

所以，如果我们将 `int test_p = (int)test` 存储在从1000H到1003H的内存地址上，那么：

- 1000H 将存储 `0x08`（因为是大端模式，所以最高字节放在最低地址）
- 1001H 将存储 `0x07`
- 1002H 将存储 `0x06`
- 1003H 将存储 `0x05`

因此，1000H上存储的是 `0x08`。

### 对比

上述中如果没有使用强制转换，在内存中，这些值将按照它们在数组中的顺序连续存储。

这个存储顺序与字节序（大端或小端）无关，因为这里没有进行多字节数据的解释，仅仅是单个字符的连续存储。

```markdown
内存地址    存储的内容
1000H        0x01
1001H        0x02
1002H        0x03
1003H        0x04
1004H        0x05
1005H        0x06
1006H        0x07
1007H        0x08
```
