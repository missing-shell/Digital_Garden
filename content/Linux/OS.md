## 进程、线程
### 什么是进程，线程，彼此的区别 ⭐⭐⭐

### 什么时候用进程，什么时候用线程？⭐⭐

### 一个线程占多大内存⭐⭐⭐

### 什么是信号量，有什么作用？⭐⭐

### 多进程内存共享可能存在什么问题？如何处理？⭐⭐⭐⭐⭐

### 多进程、多线程的优缺点⭐⭐⭐⭐

### 并发、并行

#### 线程间通信

#### 进程通信中的管道实现原理是什么?⭐⭐

### 什么是线程同步和互斥⭐⭐⭐

### 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？⭐

### 并发，同步，异步，互斥，阻塞，非阻塞的理解⭐⭐⭐⭐⭐
### 一个进程可以创建多少线程，和什么有关⭐
### 什么是进程上下文、中断上下文？⭐⭐⭐
#### 进程上下文（Process Context）

#### 中断上下文（Interrupt Context）

### 父进程、子进程的关系以及区别⭐⭐

### 孤儿进程、僵尸进程、守护进程的概念⭐⭐⭐

#### 正确处理僵尸进程的方法⭐⭐

#### 如何创建守护进程⭐⭐⭐⭐⭐
### 进程线程的状态转换图

### CPU工作原理⭐⭐

### 死锁的原因、条件？以及如何预防⭐⭐⭐
#### 死锁必要条件

#### 预防死锁的方法

#### 死锁

#### 活锁
- 活锁指的是多个线程不断重试，但最终无法取得进展的情况。线程们在不断改变自己的状态，但总是无法成功完成所需的操作。
- 活锁是一种动态状态，线程不断重试，但无法使程序向前推进。
- 活锁通常是由于*竞争条件*、过度的自旋等问题引起的。
#### 解决活锁问题的一般策略

- 引入*随机性*：通过引入随机因素，使 线程的行为具有一定的不确定性，避免线程们不断重复相同的操作。
- 使用*策略*：在活锁发生时，采用某种策略，例如放弃一部分工作、转让任务或等待一段随机时间等。
- 调整*线程优先级*：适当调整线程的优先级，以改变线程的竞争行为。
- 重新设计算法和*协调*：如果活锁是由于设计问题引起的，需要重新设计算法或协调机制，以避免竞争条件。
### sleep和wait的区别？⭐⭐⭐

### 互斥锁
#### 互斥锁的机制 ⭐⭐

#### 互斥锁与读写锁（读写互斥锁）的区别 ⭐⭐

### 中断
#### 中断怎么发生，中断处理大概流程⭐⭐

## I/O
### 五种IO模式

### 简述epoll,poll和select的区别⭐⭐⭐⭐

### epoll 水平与边缘触发

### epoll为什么高效？

## 虚拟内存和物理内存的区别⭐
## 基础概念
### Linux系统的组成部分

### 32位Linux系统的寻址空间

### Linux系统中进程默认栈空间

### Linux系统中调试崩溃问题的流程

### 用户空间与内核通信方式

### 常见信号及其含义

### 信号量在进程中的使用

### 线程池的设计思路

### 线程池中线程数量确定因素

### Linux的fork作用

## Linux 命令
### Linux中查看进程运行状态的指令、tar解压文件的参数

#### tar 解压文件的参数

### Linux下检查内存状态的命令

### 如何创建一个新的目录

### 如何以 root 权限运行某个程序

### 在 Linux 中如何查看一个想知道的进程

### 在 Linux 中如何查看带有关键字的日志文件

### Linux 修改主机名的命令

### 关于 *ping* 命令

### GDB 常见的调试命令，什么是条件断点，多进程下如何调试
## 虚拟机制与页表
### 文件系统的作用

### 进程调度算法

### LRU算法及其实现

### 页表及其作用

### 缺页中断

### 虚拟内存与物理内存

### 虚拟地址到物理地址的映射

### 中断与异常的区别

### 中断处理流程

### 操作系统的文件访问方式

## Linux内核

### 内核态与用户态的区别

### 用户空间和内核通信的方式

### Linux内核的组成

### 段页式内存管理的优点

### 系统调用与普通函数调用的区别

### 系统调用的作用

### 系统调用read/write的内核处理流程

### bootloader与内核和根文件系统的关系

### bootloader的两个阶段启动过程

### Linux内核的装载

### 为什么需要Bootloader

### Linux内核同步方式总结
