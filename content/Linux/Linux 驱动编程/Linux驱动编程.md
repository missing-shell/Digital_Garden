## 驱动演进
原始架构`v2.4`->平台总线`v2.6`->设备树`v3.x`
设备节点`mknod`->自动生成节点
**分离**--实际上是一种模块化设计思路
**分层**--`Linux`中应用很普遍，屏蔽底层细节，增加了易用性
![[Linux驱动演进.png]]
### 原始架构
- ==设备节点==--设备文件`/dev/xxx`，上层应用与底层驱动的桥梁
- Linux：设备即文件`read,write`
- 主设备号，次设备号，`mknod()`
- 结构体`file_operations`函数指针
- `register_chadev()`--==系统注册==
- 用户态`read()`->`sys_read()`->`vfs_read()`->驱动`read()`
- 原始架构依旧很重要，被后续版本封装和继承
![[原始架构read流程.png]]
### 平台总线
- `v2.6`封装了原始架构，更加抽象
- 引入设备驱动模型`sysfs`，使得**热插拔/电源管理**得以加强
- 实现了`BSP`与驱动分离
![[platform总线.png]]

### 设备树
- **设备资源**独立出来`arch/arm/mach-xxx/board-xxx.c`，从`c`文件发展为`DTS`设备树脚本文件`arch/arm/boot/dts/xxx.dts`
- 更换硬件设备时，不需要编译`Linux`操作系统，只要换个**设备树**文件就好
- `BootLoarder`参与传递设备资源（启动时把设备树文件传给内核）
![[Linux设备树框图.png]]
## 相关概念
### 系统移植`linux`驱动移植
- 同一个操作系统，不同的硬件
![[设备驱动移植步骤.png]]
### 驱动分类
> 驱动针对的对象是**存储器**和**外设**（包括`CPU`内部集成的存储器和外设，而不是针对`CPU`内核。`Linux`将存储器和外设分为`3`个基础大类：字符设备驱动，块设备驱动，网络设备驱动。

- 字符设备和块设备的驱动设计有出很大的差异，但是对于用户而言，它们都要使用文件系统的操作接口`open()`、`close()`、`read()`、`write()`等进行访问。
- 内核与网络设备的通信与内核和字符设备、网络设备的通信方式完全不同，网络设备主要还是使用`Socket`接口。
#### 字符设备驱动
> 字符设备指那些必须以**串行顺序**依次进行访问的设备，如触摸屏、磁带驱动器、鼠标等。
#### 块设备驱动
> 块设备可以按**任意顺序**进行访问，以块为单位进行操作，如硬盘、`eMMC`等。
#### 网络设备驱动
> 网络设备面向**数据包**的接收和发送而设计，它并不倾向于对应于文件系统的节点。

