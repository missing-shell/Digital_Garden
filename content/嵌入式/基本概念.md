## 嵌入式

### 嵌入式定义
- *以应用为中心*：嵌入式系统的设计是为了满足特定的应用需求。与通用计算机系统不同，嵌入式系统的功能紧密围绕在**特定**的应用场景中。
- *以计算机技术为基础*：嵌入式系统依赖计算机技术，包括嵌入式微处理器、嵌入式操作系统等。这些技术支持嵌入式系统进行计算和控制。
- *软件硬件可剪裁*：嵌入式系统的设计允许根据具体应用的需求对软件和硬件进行**定制和裁剪**。这种灵活性有助于优化系统的性能和**资源利用**。
- *适应应用系统对要求的严格要求*：嵌入式系统通常面临功能、成本、体积和功耗等方面的极端要求。设计过程需要在这些要求之间找到平衡点，以最优化系统性能。
- *由嵌入式微处理器、外围硬件设备、嵌入式操作系统以及用户应用软件等部分组成*：嵌入式系统主要包括嵌入式微处理器、外围硬件设备、嵌入式操作系统和用户应用软件。这些组成部分共同协作，使嵌入式系统能够完成其指定的任务。

### 嵌入式系统中的时钟同步⭐⭐⭐
#### 定义
> 时钟同步确保多个组件或设备使用**相同的时钟信号**进行操作，以确保系统的稳定性和可靠性。

- 在嵌入式系统中，时钟同步是关键因素，因为不同组件或设备的时钟必须保持一致以便协同工作。
- 时钟同步可以确保数据在正确的时刻传输、协同操作按照预定的时间顺序进行，同时避免数据损坏和操作错误。
#### 同步方式

- *硬件时钟*：在某些嵌入式系统中，可以通过硬件机制实现时钟同步。例如，采用外部时钟源或精确的晶振来提供系统时钟，所有组件或设备通过共享这个硬件时钟来保持同步。
- *软件时钟同步*：在某些情况下，嵌入式系统通过软件算法来实现时钟同步。使用软件时钟同步需要一个主节点或主控制器，它负责向其他组件发送时间同步消息或数据包，并根据接收的反馈调整各个组件的本地时钟。
- *网络时钟同步*：在分布式嵌入式系统中，时钟同步可以通过网络协议来实现。例如，使用网络时间协议（`NTP`）或精确时间协议（`PTP`）等协议来同步设备的时钟。这种方法通常适用于需要高精度的时钟同步，例如工业自动化系统或通信系统。。
#### SNTP
#todo

## MCU
### 组成
> 单片机(`Micro controller Unit`, `MCU`)是一种集成电路芯片
- 包含了中央处理器(`CPU`)、存储器(`ROM`和`RAM`)、输入/输出接口(`I/O`)等基本功能单元,并集成在同一块硅片上。
### MCU、DSP、MPU、SoC、FPGA

| 设备类型   | MCU (Microcontroller Unit)        | DSP (Digital Signal Processor) | MPU (Microprocessor Unit)                | SoC (System-on-Chip)       | FPGA (Field Programmable Gate Array) |
| ------ | --------------------------------- | ------------------------------ | ---------------------------------------- | -------------------------- | ------------------------------------ |
| *名称*   | 单片机                               | 数字信号处理器                        | 微处理器                                     | 系统级芯片                      | 现场可编程门阵列                             |
| *定义*   | 一种集成了处理器核心、存储器、可编程输入输出外设等多种功能的芯片。 | 一种专门设计用于处理数字信号的微处理器。           | 一种主要包含中央处理单元（`CPU`），但不集成或部分集成内存和外设接口的芯片。 | 将多种功能模块集成在一个芯片上，形成一个完整的系统。 | 一种可以通过编程来改变内部结构的芯片。                  |
| *特点*   | *体积小*、成本低、功耗低、控制功能强。              | 实时处理能力强、运行速度快、适合复杂算法。          | 性能强大、灵活性高、扩展性强。                          | 高度集成、功能全面、设计简化、成本效益高。      | 灵活性高、可定制性强、开发周期短。                    |
| *应用场景* | 嵌入式系统、家用电器控制、工业自动化等领域。            | 音频处理、视频压缩、雷达信号处理等领域。           | 个人计算机、服务器、高端嵌入式系统等需要高性能计算的场合。            | 智能手机、平板电脑、智能家居设备等复杂电子产品。   | 通信设备、视频处理、军事和航空航天等领域。                |

## 流水线
### 嵌入式流水线？⭐⭐
#### 定义
> 嵌入式流水线是一种**处理器**设计技术，旨在将处理器的工作分解成多个阶段，如指令获取、指令解码、执行、访存和写回等。每个阶段执行特定任务，使得不同指令可以并行处理，从而提高处理器的效率和性能。

- *取指阶段*：在这个阶段，处理器从指令存储器中获取一条指令，并将其送入流水线。这个阶段的主要任务是读取指令、确定指令类型以及确定指令需要的操作数。
- *译码阶段*：取得的指令会经过译码阶段，处理器会对指令进行译码，确定指令的操作类型、操作数和执行的具体方式。这个阶段还会检测指令中是否有数据相关，以便保证流水线的正确运行。
- *执行阶段*：在执行阶段，指令对应的操作会被执行，可能会涉及到算术逻辑运算、存储器访问等操作。处理器会根据指令的类型和操作数执行相应的操作。
- *访存阶段*：如果指令涉及到内存读写操作，那么在这个阶段会进行存储器的访问，包括从内存中读取数据或将数据写入内存。
- *写回阶段*：最后一个阶段是写回阶段，处理器会将执行阶段得到的结果写回到寄存器文件或者内存中，以完成整个指令的执行过程。
#### 流水线的好处
- *提高吞吐量*：流水线允许处理多条指令的不同阶段同时进行，从而提高了指令的吞吐量，加快了程序执行速度。
- *降低延迟*：流水线可以减少单个指令的执行时间，因为不同指令的不同阶段可以并行执行，从而降低了**整体处理时间**。
- *高效利用资源*：通过**并行处理**，流水线可以更充分地利用处理器资源，提高系统整体的效率和性能。
### 什么是乱序执行？⭐⭐
> 乱序执行是一种处理器执行指令的技术，其目的是通过动态调度指令的执行顺序，以提高处理器的性能和效率。

- 根据指令之间的相关性和各功能单元的*空闲状态*，动态地选择可以立即执行的指令，而不是严格按照程序的指令顺序执行。
- 执行完成后，处理器会确保乱序执行的指令的结果会按照程序指定的顺序*重新进行排序*，以保证程序的结果与顺序执行相同。
### 超流水线？⭐

#### 定义
> 超流水线是一种处理器架构设计技术，旨在提高处理器的**时钟频率**和**指令吞吐量**。

- 在传统的流水线中，每个指令都按照固定的阶段被分配执行，而每个阶段需要等待前一个指令完成后才能开始执行下一个指令。
- 超流水线则进一步*细分*了指令的执行步骤，将处理器的执行过程分为*更多个时钟周期*。这样可以使整个流水线更长，每个阶段的时间更短，从而处理器可以在一个时钟周期内完成更多的指令，提高*指令吞吐量*。
#### 特点

- 更细致的流水线阶段：超流水线将指令的执行过程分为更多个阶段，例如取指令、译码、执行、访存、写回等，以使得每个阶段的时钟周期更短。
- 更高的时钟频率：由于每个阶段的时钟周期更短，处理器在同样的时间内可以完成更多的阶段，从而可以以更高的时钟频率工作，提高处理器的性能。
#### 挑战

- *数据相关性*：更细致的流水线阶段可能导致更多的数据相关性，需要更多的硬件逻辑来解决相关性冲突，避免错误的结果。
- *分支预测*：超流水线中的分支指令可能影响流水线的正常运行，需要精确的分支预测机制来减小分支带来的停顿。
- *资源冲突*：更长的流水线需要更多的硬件资源，包括功能单元、寄存器等，而这些资源在同一周期可能会被多个指令竞争使用，需要更复杂的调度和分配机制。
## I/O与CPU信息传递方式
- [[嵌入式/外设/中断|中断]]⭐⭐⭐⭐
- [[DMA]]⭐⭐⭐⭐
## 外设
### 定时器⭐⭐⭐⭐
#### 定义
> 根据*计数器*的计数值和计数时间周期来实现定时功能。

- 定时器是SoC（系统片上芯片）中常见的外设。

#### 作用
> 允许Soc在执行主程序的同时具有计时功能
> 在定时结束可以触发中断，执行预先设置的事件和任务

#### 原理
> 定时器内部有一个计数器，它根据**时钟源**提供的时钟信号进行计数。

- 每隔一个时钟周期，计数器就会计数一次，定时器的时间就是**计数器计数值**乘以==时钟周期==。
- 定时器还包含一个寄存器（如`TCNT`），**初始计数值**会存储在寄存器中。
- 每经过一个时钟周期，寄存器中的值会自动减`1`，直到寄存器中的值减为`0`时，定时器会触发中断或执行特定的事件。


## 存储
### 分类

| **存储器类型**             | **描述**                               |
| --------------------- | ------------------------------------ |
| `Cache` 存储器           | 加速访问主存储器中的数据的存储器，包括`CPU`缓存和*磁盘缓存*等。  |
| 内存 (`RAM`)            | *临时存储*数据和程序的主要存储器类型。包括`DRAM`和`SRAM`。 |
| 只读存储器(`ROM`)          | 存储*固定数据*，如固件和`BIOS`。                 |
| 快闪存储器(`Flash Memory`) | 在**断电**的情况下可以*存储*数据。常用于`SSD`和便携设备。   |
| 磁盘存储器(`Disk Storage`) | 长期数据存储，包括硬盘驱动器(`HDD`)和固态硬盘(`SSD`)。   |
| 存储介质                  | 长期数据备份和存档，包括磁带、光盘等。                  |

| 特征/类别    | NAND Flash            | NOR Flash         |
| -------- | --------------------- | ----------------- |
| *存储容量*   | 高容量                   |                   |
| *存储密度*   | 较高的存储密度               |                   |
| *成本*     |                       | 单位成本较高            |
| *擦除时间*   | 擦除时间较短                |                   |
| *擦写次数*   | 一般在**一百万次**左右         | 一般在**十万次**左右      |
| *读取速度*   |                       | `较快`，支持`随机访问`     |
| *写入速度*   | 较快                    |                   |
| *擦除单位*   | `扇区/块`                | `扇区/块`            |
| 擦除机制     | 通过栅极和衬底之间的隧穿效应        | 通过栅源之间的隧穿效应       |
| 写入机制     | 通过F-N隧穿效应             | 通过热电子注入           |
| *接口*     | 复杂的`I/O`口**串行**地存取数据  | 有通用的`SRAM`接口，易于连接 |
| *数据和地址线* | 共用-->只能按`块`读写         | 分开-->`字节`随机访问     |
| *应用领域*   | 数据存储，如U盘、MP3          | 代码存储，如`ROM`       |
| *数据可靠性*  |                       | 较高                |
| *启动盘适用性* | 需要*特定*功能的`CPU`才能作为启动盘 | 直接作为启动盘           |

#### Cache
> Cache（缓存）是一种用于提高处理器性能的高速存储器，用于存储最常用的数据和指令。

- Cache的主要思想是利用**局部性原理**，即程序在某个时刻访问的数据很可能在近期或将来的某个时刻再次被访问。
- Cache中将存储那些频繁被访问的数据块（通常是以缓存行为单位），以作为对*主内存*中数据的一种缓存。
### ROM RAM的概念浅析⭐⭐
*页（Page）< 扇区（Sector）< 块（Block）< 芯片（Chip）*

| 特征    | ROM(只读寄存器）      | RAM (随机存取存储器)     |
| ----- | --------------- | ----------------- |
| 可读写   | 只读              | 可读写               |
| 数据固化  | 是               | 否                 |
| 数据易失性 | 否               | *是*               |
| 数据保持性 | 断电时数据保持不变       | *断电*时数据*丢失*       |
| 访问方式  | *顺序*读取          | *随机*读取            |
| 用途    | 存储固件、引导程序、常量数据等 | 存储操作系统、应用程序、临时数据等 |
| 访问速度  | 相对较慢            | 相对较快              |
| 存储容量  | 通常较小            | 通常较大              |

| 特性     | DRAM | SRAM  |
| ------ | ---- | ----- |
| 存储速度   | 较慢   | 较快    |
| 是否需要刷新 | 是    | 否     |
| 组成     | 电容   | *锁存器* |
| 集成度    | 较高   | 较低    |
| 成本     | 较低   | 较高    |

### CPU 内存 虚拟内存 磁盘/硬盘 的关系⭐

| 组件    | 描述                                    | 关系与作用                                                |
| ----- | ------------------------------------- | ---------------------------------------------------- |
| CPU   | 中央处理器，负责执行指令和处理数据。                    | 从内存中读取指令和数据，并进行处理。CPU 的性能影响系统的整体运行效率。                |
| 内存    | 临时存储数据和程序，方便CPU 快速访问。                 | 直接影响系统的运行速度和多任务处理能力。内存容量越大，可以同时运行的应用程序越多。            |
| 虚拟内存  | 允许系统使用硬盘空间作为*临时存储*，以*扩展内存容量*。         | 当物理内存被充分使用时，操作系统将一些不常用的数据移动到硬盘上的页面文件或交换空间，释放物理内存。    |
| 磁盘/硬盘 | 用于长期存储数据和程序的设备，包括机械硬盘（HDD）和固态硬盘（SSD）。 | 存储操作系统、应用程序和用户数据。在启动时从磁盘加载操作系统到内存中，并在运行过程中不断向磁盘读写数据。 |
|       |                                       |                                                      |

### 单片机的程序在哪里存储？
#### ROM组成
---
- `Code`：代码段，存放程序的代码部分；
- `Ro-data`： 表示程序定义的常量（`const`修饰的常量、`#define` 宏定义等）;
- `Rw-data`： 读写数据段，存放初始化为非 0 值的全局变量；
- `Zi-data`： 包含程序中所有*未初始化*或明确初始化为*零*的全局变量和静态变量。这部分数据在`Flash`中不占用空间，因为它不需要存储初始值
#### RAM组成
- *栈区*（`stack`）：由**编译器**自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 这些值是可读写的，那么stack应该被包含在RW-data(读写数据存储区)，也就是单片机的sram中。
- *堆区*（`heap`）：一般由**程序员**分配释放， 若程序员不释放，程序结束时可能由OS回收 。可以理解，这些也是被包含在单片机的sram中的。
- *全局区/静态区*（`static`）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。这些数据也是可读可写的，和`stack`、`heap`一样，被包含在`RAM`中。
- *文字常量区*：常量字符串就是放在这里的。这些数据是只读的，分配在`Ro-data`(只读数据存储区)，则被包含在`flash`中。
- *程序代码区*：存放函数体的二进制代码，可以想象也是被包含在`flash`，因为对于`MCU`来说，当其重新上电，代码还会继续运行，并不会消失，所以存储在flash中。
#### 存储分布
最终生成的可执行文件大小为各个部分的总和：`Code`+`RO Data`+`RW DATA `三部分，`ZI Data` 不占用文件空间，即可执行文件不包含`ZI Data`。
##### 未初始化ROM和RAM分布
> 未初始化之前的RAM里面所有区域都是**随机的值**即：`Zi-data`

![[初始化之前的ROM和RAM中的数据分布.png]]
##### 初始化之后的ROM和RAM中的数据分布
> 初始化的时候会由`Boot`程序（进入`main`函数之前）拷贝`Flash`里面的`Rw-data`区域到`RAM`，为`ZI-data`段在`RAM`中分配空间，并将其所有内容初始化为`0`。

![[初始化之后的ROM和RAM中的数据分布.png]]

- 上电初始化之后`Flash`的`Rw-data`就不会再使用了，除非重新上电、复位了`boot`才会重新从`ROM`（`Flash`）中拷贝`Rw-data`区域到`RAM`中去。
- 运行时，根据上一节对==哈佛模型==的描述（51内核、Cortex-M3、Cortex-M4是哈佛模型）,程序存储区对应`ROM`（`Flash`）数据存储区对应`RAM`，如此这般两个区域就是物理上的分开的–经典的哈佛模型。

![[初始化之后正常运行时，单片机内ROM和RAM区域分布图.png]]